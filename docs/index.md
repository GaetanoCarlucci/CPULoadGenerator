---
layout: default
title: CPU Load Generator
---

# CPU Load Generator Project

Welcome to the CPU Load Generator project, a Python-based tool designed to generate a fixed CPU load for a finite period using a PID regulator. This tool is particularly useful for system administrators, developers, and researchers.

## Motivation

The CPU Load Generator serves multiple purposes:

- **Performance Testing**: Stress test applications and systems by generating a specific CPU load, helping identify performance bottlenecks and ensuring robustness under different load conditions.
- **Resource Allocation Optimization**: Simulate various load scenarios to optimize resource allocation and ensure critical applications receive the necessary computational power.
- **Benchmarking**: Provide a consistent and repeatable load for precise benchmarking, facilitating the comparison of different systems, CPUs, or configurations.
- **Education and Training**: Demonstrate the effects of CPU load on system performance, offering hands-on experience for students and trainees. University students can also understand the practical application of a PID regulator in a discrete environment.
- **Thermal and Power Consumption Analysis**: Study the thermal behavior and power consumption of CPUs under controlled load conditions.

## PID Regulator for Controlling CPU Load

The design of the CPU Load Generator involves several components:

- **CPU Target Load**: Desired percentage of CPU load on a specific core.
- **Monitor Thread**: Measures the percentage of actual CPU load on the specific core.
- **Error**: Percentage error of measured CPU load with respect to the target.
- **Controller Thread**: PID regulator with integral and proportional actions.
- **Controller Output**: The actuator signal that adjusts the CPU core load based on the measured error.
- **CPU Load**: The actual plant is the specific CPU core load.
- **Disturb**: Any other process that can disturb the CPU core load.
- **Process Variable**: The actual CPU load measured by the Monitor Thread after the control action.

### Monitor Thread

The Monitor Thread samples the CPU load at regular intervals, filters the measurements with a first-order filter, and logs various parameters over time. The value measured by the Monitor Thread is calculated using the `psutil` method `cpu_percent(interval)`, which calculates the CPU usage during the specified interval. The call to `cpu_percent` blocks the thread for the duration of the interval, ensuring that the loop naturally waits for the specified sampling time before proceeding to the next iteration. In this case, `psutil.Process` is used, meaning that the method measures the CPU usage generated by this particular process.

### Controller Thread

The Controller Thread compares the CPU load measured by the Monitor Thread and the target CPU load (set point). Based on the difference between them (tracking error), the PID regulator computes the control signal and sends it to the actuation device, which in turn drives the plant to the desired process value (set point).

When the error is fed to the PID regulator, it computes the:

- **P** (Proportional)
- **I** (Integral)
- **D** (Derivative)

contributions of this error signal with respect to time. In this project, the derivative contribution is not used. The proportional and integral components are weighted by coefficients and then summed up. The output of this operation is the actuator signal, which in our case is the sleep time used in the actuator function that generates CPU load.

```python
def generate_load(self, sleep_time):
    interval = time.time() + self.period - sleep_time
    # generates some CPU load for interval seconds
    while time.time() < interval:
        pr = 213123  # generates some load
        _ = pr * pr
        pr = pr + 1
    time.sleep(sleep_time)
