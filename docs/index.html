---
layout: default            # use the layout that ships with jekyll-theme-minimal
title: CPU Load Generator   # appears in the <title> tag and navbar (if any)
---

<!-- lightweight, self‑contained styling -->
<style>
  :root {
    --accent: #0069d9;
    --bg: #f7f9fc;
    --text: #222;
    --code-bg: #eee;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    line-height: 1.6;
    color: var(--text);
    background: var(--bg);
  }
  header {
    background: var(--accent);
    color: #fff;
    padding: 2rem 1rem;
    text-align: center;
  }
  header h1 { margin: 0 0 .25rem; font-size: 2.25rem; }
  header a { color: #fff; font-weight: 600; text-decoration: underline; }
  main {
    max-width: 58rem;
    margin: 2rem auto;
    padding: 0 1rem;
  }
  section {
    background: #fff;
    padding: 2rem 1.5rem;
    border-radius: .85rem;
    box-shadow: 0 2px 6px rgba(0,0,0,.08);
    margin-bottom: 2rem;
  }
  h2 { margin-top: 0; color: var(--accent); }
  h3, h4 { color: var(--accent); margin-bottom: .25rem; }
  img { max-width: 100%; height: auto; border-radius: .5rem; }
  ul { padding-left: 1.25rem; }
  pre, code {
    font-family: ui-monospace, "SFMono-Regular", Consolas, monospace;
    background: var(--code-bg);
    border-radius: .35rem;
  }
  pre { padding: .75rem 1rem; overflow-x: auto; }
  footer {
    text-align: center;
    padding: 1rem;
    font-size: .9rem;
    color: #666;
  }
</style>

<!-- ===== Hero ===== -->
<header>
  <h1>CPU Load Generator</h1>
  <p>
    Generate a fixed, precisely regulated CPU load with a lean Python script that uses a PID controller.<br />
    <a href="https://github.com/GaetanoCarlucci/CPULoadGenerator"
       target="_blank" rel="noopener">View the project on GitHub ↗︎</a>
  </p>
</header>

<main>
  <!-- ===== Motivation ===== -->
  <section id="motivation">
    <h2>Motivation</h2>
    <p>
      This project shows system administrators, developers, and researchers how to create a
      <strong>stable CPU load for a finite period</strong> by closing the loop with a PID regulator.
    </p>
    <ul>
      <li><strong>Performance&nbsp;testing:&nbsp;</strong>Stress‑test applications and full systems to uncover bottlenecks and verify robustness under load.</li>
      <li><strong>Resource‑allocation optimisation:&nbsp;</strong>Reproduce real‑world utilisation scenarios so you can fine‑tune CPU quotas and scheduling policies.</li>
      <li><strong>Benchmarking:&nbsp;</strong>Generate a consistent, repeatable workload that makes it easy to compare CPUs, machines, or configurations.</li>
      <li><strong>Education&nbsp;&amp;&nbsp;training:&nbsp;</strong>Give students hands‑on experience with discrete PID control and demonstrate how load impacts performance.</li>
      <li><strong>Thermal&nbsp;/&nbsp;power analysis:&nbsp;</strong>Investigate heat dissipation and energy consumption under a controlled, steady workload.</li>
    </ul>
  </section>

  <!-- ===== PID Regulator ===== -->
  <section id="pid">
    <h2>PID regulator for controlling CPU load</h2>
    <img src="https://gaetanocarlucci.altervista.org/wp-content/uploads/2024/07/pid-1.png"
         alt="PID control diagram" loading="lazy">
    <p>
      The architecture uses two threads: a <em>Monitor Thread</em> that measures CPU
      utilisation and a <em>Controller Thread</em> that applies PI control to adjust
      the sleep time of a tight loop so the measured load matches the
      target.
    </p>

    <h3>Monitor Thread</h3>
    <p>
      Samples CPU usage at a fixed interval via
      <code>psutil.cpu_percent(interval)</code>, filters the measurements with a
      first‑order filter and logs the results.
    </p>

    <h3>Controller Thread</h3>
    <p>
      Compares the target load (<em>set‑point</em>) and actual load, then computes the
      control signal using proportional (<code>K<sub>p</sub></code>) and integral
      (<code>K<sub>i</sub></code>) actions. The derivative term is not used.
    </p>

```python
# actuator snippet
def generate_load(self, sleep_time):
    interval = time.time() + self.period - sleep_time
    while time.time() < interval:
        pr = 213123        # busy‑work
        _ = pr * pr
        pr = pr + 1
    time.sleep(sleep_time)
